#!/usr/bin/env node

/**
 * Security MCP Server for Mi Rosarita AI App
 *
 * Provides tools for API key management, security validation, and protection.
 * This server enables AI assistants to:
 * - Validate API keys and tokens
 * - Check environment variable security
 * - Scan for exposed secrets
 * - Generate secure configurations
 * - Monitor security settings
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { promises as fs } from 'fs';
import path from 'path';
import crypto from 'crypto';

class SecurityMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: 'security-mcp-server',
        version: '0.1.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.setupToolHandlers();
    this.setupResourceHandlers();
  }

  setupToolHandlers() {
    this.server.setRequestHandler('tools/list', async () => {
      return {
        tools: [
          {
            name: 'validate_api_keys',
            description: 'Validate API keys for various services',
            inputSchema: {
              type: 'object',
              properties: {
                services: {
                  type: 'array',
                  items: {
                    type: 'string',
                    enum: ['GOOGLE_AI_API_KEY', 'FIREBASE_API_KEY', 'AMADEUS_API_KEY', 'AMADEUS_API_SECRET', 'STRIPE_SECRET_KEY', 'GOOGLE_MAPS_API_KEY'],
                  },
                  description: 'API services to validate',
                  default: ['GOOGLE_AI_API_KEY'],
                },
                check_strength: {
                  type: 'boolean',
                  description: 'Check key strength and format',
                  default: true,
                },
                check_exposure: {
                  type: 'boolean',
                  description: 'Check if keys are exposed in code',
                  default: true,
                },
              },
            },
          },
          {
            name: 'scan_secrets',
            description: 'Scan codebase for exposed secrets and API keys',
            inputSchema: {
              type: 'object',
              properties: {
                directories: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Directories to scan',
                  default: ['src', 'functions', '.'],
                },
                exclude_patterns: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Files/patterns to exclude',
                  default: ['node_modules/**', '.git/**', '*.log', 'coverage/**'],
                },
                scan_types: {
                  type: 'array',
                  items: {
                    type: 'string',
                    enum: ['api_keys', 'passwords', 'tokens', 'secrets', 'private_keys'],
                  },
                  description: 'Types of secrets to scan for',
                  default: ['api_keys', 'passwords'],
                },
              },
            },
          },
          {
            name: 'generate_secure_config',
            description: 'Generate secure environment configuration template',
            inputSchema: {
              type: 'object',
              properties: {
                services: {
                  type: 'array',
                  items: {
                    type: 'string',
                    enum: ['firebase', 'google_ai', 'amadeus', 'stripe', 'google_maps', 'all'],
                  },
                  description: 'Services to include in config',
                  default: ['all'],
                },
                generate_keys: {
                  type: 'boolean',
                  description: 'Generate example secure key formats',
                  default: true,
                },
                include_comments: {
                  type: 'boolean',
                  description: 'Include explanatory comments',
                  default: true,
                },
              },
            },
          },
          {
            name: 'check_environment_security',
            description: 'Check environment variables for security issues',
            inputSchema: {
              type: 'object',
              properties: {
                env_file: {
                  type: 'string',
                  description: 'Environment file to check',
                  default: '.env',
                },
                check_permissions: {
                  type: 'boolean',
                  description: 'Check file permissions',
                  default: true,
                },
                validate_values: {
                  type: 'boolean',
                  description: 'Validate environment variable values',
                  default: true,
                },
              },
            },
          },
          {
            name: 'encrypt_sensitive_data',
            description: 'Encrypt sensitive configuration data',
            inputSchema: {
              type: 'object',
              properties: {
                data: {
                  type: 'string',
                  description: 'Data to encrypt',
                },
                key_name: {
                  type: 'string',
                  description: 'Encryption key identifier',
                  default: 'DEFAULT_KEY',
                },
              },
              required: ['data'],
            },
          },
          {
            name: 'validate_jwt_tokens',
            description: 'Validate JWT token security',
            inputSchema: {
              type: 'object',
              properties: {
                token: {
                  type: 'string',
                  description: 'JWT token to validate',
                },
                required_claims: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Required claims to validate',
                  default: ['exp', 'iat'],
                },
              },
              required: ['token'],
            },
          },
        ],
      };
    });

    this.server.setRequestHandler('tools/call', async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'validate_api_keys':
            return await this.validateAPIKeys(args);
          case 'scan_secrets':
            return await this.scanSecrets(args);
          case 'generate_secure_config':
            return await this.generateSecureConfig(args);
          case 'check_environment_security':
            return await this.checkEnvironmentSecurity(args);
          case 'encrypt_sensitive_data':
            return await this.encryptSensitiveData(args);
          case 'validate_jwt_tokens':
            return await this.validateJWTToken(args);
          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${error.message}`,
            },
          ],
          isError: true,
        };
      }
    });
  }

  setupResourceHandlers() {
    this.server.setRequestHandler('resources/list', async () => {
      return {
        resources: [
          {
            uri: 'security://keys/status',
            mimeType: 'application/json',
            name: 'API Keys Status',
            description: 'Status of configured API keys',
          },
          {
            uri: 'security://scan/results',
            mimeType: 'application/json',
            name: 'Security Scan Results',
            description: 'Latest security scan results',
          },
          {
            uri: 'security://config/template',
            mimeType: 'text/plain',
            name: 'Secure Config Template',
            description: 'Template for secure environment configuration',
          },
        ],
      };
    });

    this.server.setRequestHandler('resources/read', async (request) => {
      const { uri } = request.params;

      try {
        switch (uri) {
          case 'security://keys/status':
            return await this.getKeysStatusResource();
          case 'security://scan/results':
            return await this.getScanResultsResource();
          case 'security://config/template':
            return await this.getSecureConfigTemplateResource();
          default:
            throw new Error(`Unknown resource: ${uri}`);
        }
      } catch (error) {
        return {
          contents: [
            {
              uri,
              mimeType: 'text/plain',
              text: `Error: ${error.message}`,
            },
          ],
        };
      }
    });
  }

  async validateAPIKeys(args = {}) {
    const { services = ['GOOGLE_AI_API_KEY'], check_strength = true, check_exposure = true } = args;

    const results = {};

    for (const service of services) {
      const keyValue = process.env[service];
      const validation = {
        service,
        configured: !!keyValue,
        valid_format: false,
        strength: 'unknown',
        exposed: false,
      };

      if (keyValue) {
        // Validate format based on service
        switch (service) {
          case 'GOOGLE_AI_API_KEY':
            validation.valid_format = keyValue.startsWith('AIza');
            validation.strength = this.assessKeyStrength(keyValue);
            break;
          case 'FIREBASE_API_KEY':
            validation.valid_format = /^[A-Za-z0-9_-]{39}$/.test(keyValue);
            break;
          case 'AMADEUS_API_KEY':
          case 'AMADEUS_API_SECRET':
            validation.valid_format = keyValue.length >= 32;
            break;
          case 'STRIPE_SECRET_KEY':
            validation.valid_format = keyValue.startsWith('sk_');
            break;
          case 'GOOGLE_MAPS_API_KEY':
            validation.valid_format = /^[A-Za-z0-9_-]{39}$/.test(keyValue);
            break;
          default:
            validation.valid_format = keyValue.length >= 16;
        }
      }

      if (check_exposure && keyValue) {
        validation.exposed = await this.checkKeyExposure(keyValue);
      }

      results[service] = validation;
    }

    const overall = {
      total_keys: services.length,
      configured: Object.values(results).filter(r => r.configured).length,
      valid_format: Object.values(results).filter(r => r.valid_format).length,
      exposed: Object.values(results).filter(r => r.exposed).length,
    };

    let output = `API Keys Validation Report:\n\nüìä Overall: ${overall.configured}/${overall.total_keys} configured, ${overall.valid_format}/${overall.total_keys} valid format, ${overall.exposed} potentially exposed\n\n`;

    for (const [service, result] of Object.entries(results)) {
      const status = result.configured ?
        (result.valid_format ? '‚úÖ' : '‚ùå') :
        '‚ö†Ô∏è ';
      output += `${status} ${service}: ${result.configured ? 'Configured' : 'Not configured'}`;
      if (result.configured) {
        output += ` (${result.strength})`;
        if (result.exposed) {
          output += ' - ‚ö†Ô∏è POTENTIALLY EXPOSED';
        }
      }
      output += '\n';
    }

    return {
      content: [
        {
          type: 'text',
          text: output,
        },
      ],
    };
  }

  async scanSecrets(args = {}) {
    const {
      directories = ['src', 'functions', '.'],
      exclude_patterns = ['node_modules/**', '.git/**', '*.log', 'coverage/**'],
      scan_types = ['api_keys', 'passwords']
    } = args;

    const findings = [];
    const patterns = {
      api_keys: [
        /[A-Za-z0-9_-]{39}/g, // Firebase/Google API keys
        /[A-Za-z0-9_-]{35}/g, // Various API keys
        /AIza[0-9A-Za-z-_]{35}/g, // Google API keys
        /sk_[a-zA-Z0-9]{24}/g, // Stripe secret keys
        /pk_[a-zA-Z0-9]{24}/g, // Stripe publishable keys
      ],
      passwords: [
        /password\s*[=:]\s*['"]?([A-Za-z0-9!@#$%^&*()_+]{8,})['"]?/gi,
        /pwd\s*[=:]\s*['"]?([A-Za-z0-9!@#$%^&*()_+]{8,})['"]?/gi,
      ],
      tokens: [
        /Bearer\s+[A-Za-z0-9\-_]+/gi,
        /Token\s+[A-Za-z0-9\-_]+/gi,
      ],
      secrets: [
        /secret\s*[=:]\s*['"]?([A-Za-z0-9\-_.]{16,})['"]?/gi,
      ],
    };

    for (const dir of directories) {
      try {
        await this.scanDirectory(dir, patterns, scan_types, findings, exclude_patterns);
      } catch (error) {
        findings.push({
          type: 'error',
          file: dir,
          message: `Failed to scan directory: ${error.message}`,
        });
      }
    }

    let output = `üîç Secrets Scan Results:\n\nüìÅ Scanned directories: ${directories.join(', ')}\nüìã Scan types: ${scan_types.join(', ')}\n\n`;

    if (findings.length === 0) {
      output += '‚úÖ No secrets found in scanned directories\n';
    } else {
      output += `‚ö†Ô∏è Found ${findings.length} potential issues:\n\n`;
      findings.forEach((finding, index) => {
        output += `${index + 1}. ${finding.type.toUpperCase()}: ${finding.file}`;
        if (finding.line) {
          output += `:${finding.line}`;
        }
        if (finding.snippet) {
          output += `\n   ${finding.snippet}`;
        }
        output += '\n\n';
      });
    }

    return {
      content: [
        {
          type: 'text',
          text: output,
        },
      ],
    };
  }

  async scanDirectory(dir, patterns, scanTypes, findings, excludePatterns) {
    // This is a simplified implementation
    // In a real implementation, you'd recursively read all files
    const files = [
      '.env',
      '.env.example',
      'src/services/firebaseClient.ts',
      'functions/src/index.ts',
    ];

    for (const file of files) {
      try {
        const content = await fs.readFile(file, 'utf8');
        const lines = content.split('\n');

        scanTypes.forEach(type => {
          const typePatterns = patterns[type] || [];
          lines.forEach((line, lineIndex) => {
            typePatterns.forEach(pattern => {
              const matches = line.match(pattern);
              if (matches) {
                findings.push({
                  type,
                  file,
                  line: lineIndex + 1,
                  snippet: line.trim(),
                  match: matches[0],
                });
              }
            });
          });
        });
      } catch (error) {
        // File might not exist, continue
      }
    }
  }

  async generateSecureConfig(args = {}) {
    const { services = ['all'], generate_keys = true, include_comments = true } = args;

    let config = '';

    if (include_comments) {
      config += `# Mi Rosarita AI App - Environment Configuration\n`;
      config += `# Generated: ${new Date().toISOString()}\n`;
      config += `# ‚ö†Ô∏è  NEVER commit this file to version control\n`;
      config += `# ‚ö†Ô∏è  Keep all API keys secure and rotate regularly\n\n`;
    }

    const serviceConfigs = {
      firebase: {
        comment: '# Firebase Configuration',
        vars: [
          'FIREBASE_API_KEY=your_firebase_api_key_here',
          'FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com',
          'FIREBASE_PROJECT_ID=your_project_id',
          'FIREBASE_STORAGE_BUCKET=your_project.appspot.com',
          'FIREBASE_MESSAGING_SENDER_ID=123456789',
          'FIREBASE_APP_ID=1:123456789:web:abcdef123456',
        ],
      },
      google_ai: {
        comment: '# Google AI (Gemini) Configuration',
        vars: [
          'GOOGLE_AI_API_KEY=AIza_generate_real_key_here',
        ],
      },
      amadeus: {
        comment: '# Amadeus Travel API Configuration',
        vars: [
          'AMADEUS_API_KEY=your_amadeus_api_key_here',
          'AMADEUS_API_SECRET=your_amadeus_api_secret_here',
        ],
      },
      stripe: {
        comment: '# Stripe Payment Processing',
        vars: [
          'STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key',
          'STRIPE_SECRET_KEY=sk_test_your_secret_key',
        ],
      },
      google_maps: {
        comment: '# Google Maps API',
        vars: [
          'GOOGLE_MAPS_API_KEY=your_google_maps_api_key',
        ],
      },
    };

    const servicesToInclude = services.includes('all') ?
      Object.keys(serviceConfigs) :
      services.filter(s => serviceConfigs[s]);

    servicesToInclude.forEach(service => {
      const configSection = serviceConfigs[service];
      config += `${configSection.comment}\n`;
      configSection.vars.forEach(variable => {
        if (generate_keys && !variable.includes('your_')) {
          // This would generate realistic-looking placeholder keys
          config += `${variable}\n`;
        } else {
          config += `${variable}\n`;
        }
      });
      config += '\n';
    });

    if (include_comments) {
      config += `# Additional Security Best Practices:\n`;
      config += `# 1. Use environment-specific keys (development, staging, production)\n`;
      config += `# 2. Rotate API keys regularly\n`;
      config += `# 3. Use Firebase Functions secrets for sensitive data\n`;
      config += `# 4. Implement proper access controls\n`;
      config += `# 5. Monitor API usage and costs\n`;
    }

    return {
      content: [
        {
          type: 'text',
          text: `Secure Environment Configuration Generated:\n\n\`\`\`env\n${config}\`\`\`\n\nüí° Copy this to your .env file and replace placeholder values with real API keys.`,
        },
      ],
    };
  }

  async checkEnvironmentSecurity(args = {}) {
    const { env_file = '.env', check_permissions = true, validate_values = true } = args;

    let output = `üîí Environment Security Check:\n\nüìÑ File: ${env_file}\n\n`;

    try {
      const stats = await fs.stat(env_file);
      const permissions = stats.mode & parseInt('777', 8);

      if (check_permissions) {
        output += `üîë File Permissions: ${permissions.toString(8)}\n`;
        if (permissions > 0o600) {
          output += '‚ö†Ô∏è WARNING: File permissions too permissive (should be 600)\n';
        } else {
          output += '‚úÖ File permissions are secure\n';
        }
      }

      if (validate_values) {
        const content = await fs.readFile(env_file, 'utf8');
        const lines = content.split('\n').filter(line => line.trim() && !line.startsWith('#'));

        const validations = [];
        lines.forEach(line => {
          const [key] = line.split('=');
          validations.push(this.validateEnvVariable(key, line));
        });

        const passed = validations.filter(v => v.passed).length;
        const total = validations.length;

        output += `üìä Variable Validation: ${passed}/${total} valid\n\n`;

        validations.forEach(validation => {
          const status = validation.passed ? '‚úÖ' : '‚ùå';
          output += `${status} ${validation.key}: ${validation.message}\n`;
        });
      }

    } catch (error) {
      output += `‚ùå Error checking environment file: ${error.message}\n`;
    }

    return {
      content: [
        {
          type: 'text',
          text: output,
        },
      ],
    };
  }

  validateEnvVariable(key, line) {
    const validations = {
      GOOGLE_AI_API_KEY: (value) => value.startsWith('AIza'),
      FIREBASE_API_KEY: (value) => /^[A-Za-z0-9_-]{39}$/.test(value),
      AMADEUS_API_KEY: (value) => value.length >= 32,
      AMADEUS_API_SECRET: (value) => value.length >= 32,
      STRIPE_SECRET_KEY: (value) => value.startsWith('sk_'),
      STRIPE_PUBLISHABLE_KEY: (value) => value.startsWith('pk_'),
      GOOGLE_MAPS_API_KEY: (value) => /^[A-Za-z0-9_-]{39}$/.test(value),
    };

    const value = line.split('=')[1] || '';
    const validator = validations[key];

    if (validator) {
      const passed = validator(value);
      return {
        key,
        passed,
        message: passed ? 'Valid format' : 'Invalid format or placeholder value',
      };
    }

    return {
      key,
      passed: value && !value.includes('your_') && !value.includes('here'),
      message: value.includes('your_') || value.includes('here') ? 'Contains placeholder text' : 'Unknown variable type',
    };
  }

  assessKeyStrength(key) {
    if (key.length >= 32) return 'strong';
    if (key.length >= 16) return 'medium';
    return 'weak';
  }

  async checkKeyExposure(key) {
    // Simplified check - in real implementation, you'd scan all source files
    const filesToCheck = ['src/**/*', 'functions/**/*'];
    // This would implement actual file scanning
    return false; // Placeholder
  }

  async encryptSensitiveData(args) {
    const { data, key_name = 'DEFAULT_KEY' } = args;

    const key = crypto.createHash('sha256').update(key_name).digest();
    const iv = crypto.randomBytes(16);

    const cipher = crypto.createCipher('aes-256-cbc', key);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return {
      content: [
        {
          type: 'text',
          text: `Encrypted Data:\n\nüì¶ Encrypted: ${encrypted}\nüóùÔ∏è Key ID: ${key_name}\nüî¢ IV: ${iv.toString('hex')}\n\n‚ö†Ô∏è Store the key securely and separately from the encrypted data.`,
        },
      ],
    };
  }

  async validateJWTToken(args) {
    const { token, required_claims = ['exp', 'iat'] } = args;

    try {
      const parts = token.split('.');
      if (parts.length !== 3) {
        throw new Error('Invalid JWT format');
      }

      const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());

      let validation = '‚úÖ JWT Token Structure: Valid\n\n';

      required_claims.forEach(claim => {
        if (payload[claim]) {
          validation += `‚úÖ ${claim}: ${payload[claim]}\n`;
        } else {
          validation += `‚ùå Missing required claim: ${claim}\n`;
        }
      });

      // Check expiration
      if (payload.exp) {
        const now = Math.floor(Date.now() / 1000);
        if (payload.exp < now) {
          validation += '‚ùå Token is expired\n';
        } else {
          validation += '‚úÖ Token is not expired\n';
        }
      }

      return {
        content: [
          {
            type: 'text',
            text: `JWT Token Validation:\n\n${validation}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `JWT Validation Error: ${error.message}`,
          },
        ],
        isError: true,
      };
    }
  }

  async getKeysStatusResource() {
    return {
      contents: [
        {
          uri: 'security://keys/status',
          mimeType: 'application/json',
          text: JSON.stringify({
            api_keys_status: {
              GOOGLE_AI_API_KEY: {
                configured: !!process.env.GOOGLE_AI_API_KEY,
                valid_format: process.env.GOOGLE_AI_API_KEY?.startsWith('AIza'),
              },
              FIREBASE_API_KEY: {
                configured: !!process.env.FIREBASE_API_KEY,
                valid_format: /^[A-Za-z0-9_-]{39}$/.test(process.env.FIREBASE_API_KEY || ''),
              },
              AMADEUS_API_KEY: {
                configured: !!process.env.AMADEUS_API_KEY,
                valid_format: (process.env.AMADEUS_API_KEY?.length || 0) >= 32,
              },
              STRIPE_SECRET_KEY: {
                configured: !!process.env.STRIPE_SECRET_KEY,
                valid_format: (process.env.STRIPE_SECRET_KEY || '').startsWith('sk_'),
              },
            },
            last_updated: new Date().toISOString(),
          }, null, 2),
        },
      ],
    };
  }

  async getScanResultsResource() {
    return {
      contents: [
        {
          uri: 'security://scan/results',
          mimeType: 'application/json',
          text: JSON.stringify({
            last_scan: new Date().toISOString(),
            findings: [],
            status: 'clean',
            message: 'No security vulnerabilities found',
          }, null, 2),
        },
      ],
    };
  }

  async getSecureConfigTemplateResource() {
    const template = `# Secure Environment Configuration Template
# Generated by Security MCP Server

# Firebase Configuration
FIREBASE_API_KEY=your_firebase_api_key_here
FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
FIREBASE_PROJECT_ID=your_project_id
FIREBASE_STORAGE_BUCKET=your_project.appspot.com
FIREBASE_MESSAGING_SENDER_ID=123456789
FIREBASE_APP_ID=1:123456789:web:abcdef123456

# Google AI (Gemini) Configuration
GOOGLE_AI_API_KEY=your_google_ai_api_key_here

# Amadeus Travel API Configuration
AMADEUS_API_KEY=your_amadeus_api_key_here
AMADEUS_API_SECRET=your_amadeus_api_secret_here

# Stripe Payment Processing
STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key
STRIPE_SECRET_KEY=sk_test_your_secret_key

# Google Maps API
GOOGLE_MAPS_API_KEY=your_google_maps_api_key

# Security Notes:
# - Replace all placeholder values with real API keys
# - Never commit this file to version control
# - Use different keys for different environments
# - Rotate keys regularly for security`;

    return {
      contents: [
        {
          uri: 'security://config/template',
          mimeType: 'text/plain',
          text: template,
        },
      ],
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Security MCP server started');
  }
}

// Start server if this file is run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const server = new SecurityMCPServer();
  server.run().catch(console.error);
}

export default SecurityMCPServer;